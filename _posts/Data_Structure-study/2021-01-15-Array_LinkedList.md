---
layout : post
title : "배열과 연결리스트 CRUD"
featured-img: JSP-study
categories : [Data_Structure]
---
# 배열과 연결리스트의 CRUD
---
## CRUD
<b>Create</b> : 생성
<b>Read</b> : 읽기
<b>Update</b> : 수정
<b>Delete</b> : 삭제

## 배열 vs 연결리스트 : 정렬되지 않았을 경우
---
**[Create] 속도 : 연결리스트**
`배열` : 삽입할 데이터만큼의 메모리를 할당받고 기존의 데이터를 복사하고 삽입한다.  
`연결리스트` : 삽입하는 데이터의 주소를 알아내 주소를 연결만 해주면 되기 때문에 O(n)에 삽입한다.  
배열처럼 메모리를 재할당 받거나 첫번째에 삽입할 때 뒤로 밀 필요가 없기 때문에 속도면에서는 연결리스트가 빠르다. O(1)  <br>

**[Read] 속도 : 배열**  
`배열` : 인덱스를 통한 접근과 메모리가 인접한 주소끼리 뭉쳐있기 때문에 접근할 수 있어 O(1)에 접근한다.  
`연결리스트` : 인접한 주소가 아닌 떨어져있는 데이터들끼리 포인터로 주소를 접근하기 때문에 배열보다 느리다.  또한 인덱스는 있지만 배열처럼 일정한 간격으로 떨어져 있지 않기 때문에 **`random access`**가 불가능하다. 순차적으로 주소에 접근하기 때문에 O(n)에 접근한다.  <br>

**[Update] 속도 : 배열**  
`배열` : 인덱스의 값을 알고 있다면 인덱스에 해당하는 값을 새로 대입해주면된다. O(1)
`연결리스트` :  바꾸고자하는 값을 순화해서 찾은 후 바꿔주기 때문에 마지막 값을 바꿀 경우 O(n)에 접근한다. 이 이유도 random access가 불가능하기 때문이다. <br>

**[Delete] 속도 : 연결리스트**  
`배열` : 데이터를 삭제한다면 마지막 원소일 경우에는 삭제만 하면 되지만 중간이나 처음일 경우에는
데이터의 중복을 막기위해 앞으로 한칸씩 미뤄줘야 한다. O(n)에 해당함.  
`연결리스트` : 삭제할 원소의 노드를 제외한 나머지 원소를 연결해 주면 되기 때문에 속도면에서는 연결리스트가 빠르다. O(1)에 해당함 <br>
<br>

## random access 와 이진검색
---

배열과 연결리스트의 가장 큰 차이점은 **`random access`**같다.  
**`random access`** : i라는 요소를 찾는데 일정한 시간에 찾을 수 있음을 의미  
이게 가능한 이유는 배열은 일정한 크기로 주소가 인접해있는 **덩어리**이기 때문이다.<br>  
배열같은 경우는 일정한 간격으로 이루어진 하나의 메모리 덩어리라 ***(배열+int)** 해서 쉽게 값을 찾아갈 수 있지만 연결리스트는 메모리가 서로 떨어져있는 것을 연결한 것이기 때문에 불가능하다. (주소가 일정한 간격으로 있지가 않음)    
그럼에도 연결리스트를 사용하는 이유는 메모리를 효율적이게 사용하기 때문이 아닐까.  
<br>

## 이진검색트리는 왜 사용하나?  
---
Q.연결리스트로 이진검색트리를 만드는 이유는 무엇일까 메모리 많이 잡아먹는데 그냥 배열 쓰면 되지않나?  
A)연결리스트로 이진검색트리를 만들어 놓으면 삽입할때 시간은 걸리겠지만 삽입과 동시에 **정렬**이 가능하기 때문이다.  
무작위로 삽입 후 정렬을 하고 그 값을 찾으려면 오래 걸리기 때문에 삽입과 동시에 정렬이 되고 무엇보다 연결리스트는 포인터로 주소를 연결해두어 메모리를 유연하게 사용할 수 있기 때문에 이진검색트리는 배열보다 효율적이라고 말할 수 있다.
